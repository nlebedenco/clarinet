#include "platforms/unix/sys.h"
#include "portable/addr.h"

#include <unistd.h>
#include <errno.h>
#include <assert.h>

/* NOTES:
 *   - All references to errno are thread-safe. POSIX guarantees that errno is a thread-specifc global.
 *
 */

int 
clarinet_error_from_errno(const int err)
{
    /* EINPROGRESS can only be generated by connect() in which case it has the same meaning as EWOULDBLOCK. It should 
     * not be relayed to the end-user because we only operate on non-blocking sockets anyway. */
    assert(err != EINPROGRESS);
    
    /* EOPNOTSUPP should never be relayed to the end-user. It can only happen due to socket mishandling. For example by 
     * calling accept() on a udp socket or using incompatible send/recv flags. */
    assert(err != EOPNOTSUPP);

    /* EWOULDBLOCK and EAGAIN still have to be relayed to the user from send() and recv(). On linux EAGAIN and 
     * EWOULDBLOCK have the same value. This may not be true on other systems but their meaning would still be 
     * interchangeable. */
    switch(err)
    {
        case 0: 
            return CLARINET_ENONE;
        case EBADF:                         /* Bad file descriptor */
        case EFAULT:                        /* Bad address (normally a null ptr)*/
        case EINVAL:                        /* Invalid argument */
        case EAFNOSUPPORT:                  /* Address family not supported by protocol */
        case EPFNOSUPPORT:                  /* Protocol family not supported  */
            return CLARINET_EINVAL;    
        case ENOSPC:                        /* No space left on device */
        case EDQUOT:                        /* Disc quota exceeded */
        case EIO:                           /* An I/O e rror occurred. */
            return CLARINET_EIO;            
        case ENOMEM:                        /* Out of memory */
            return CLARINET_ENOMEM;           
        case EINTR:                         /* Call was interrupted by a signal */
            return CLARINET_EINTR;                   
        case ESOCKTNOSUPPORT:               /* Socket type not suported. This error should not normally be relayed to the end-user. */        
        case EPROTOTYPE:                    /* The specified protocol is the wrong type for this socket. This error should not normally be relayed to the end-user. */
        case EPROTONOSUPPORT:               /* Protocol not supported. This error should not normally be relayed to the end-user. */
            return CLARINET_ENOTSUPP;               
        case EACCES:                        /* Permission denied */
            return CLARINET_EACCES;                        
        case EMFILE:                        /* Too many open sockets */
            return CLARINET_EMFILE;         
        #if !HAVE_EAGAIN_SAME_AS_EWOULDBLOCK
        case EAGAIN:
        #endif           
        case EWOULDBLOCK:                   /* Operation could not be completed immediately */
            return CLARINET_EWOULDBLOCK;            
        case EALREADY:                      /* In other cases when an operation is already in progress a function may fail with WSAEALREADY. */        
            return CLARINET_EALREADY;       
        case ENOTSOCK:                      /* An operation was attempted on something that is not a socket. */  
            return CLARINET_ENOTSOCK;        
        case EMSGSIZE:                      /* Datagram is larger than the internal message buffer */
            return CLARINET_EMSGSIZE;        
        case ENOPROTOOPT:                   /* Bad protocol option. */    
            return CLARINET_ENOPROTOOPT;        
        case EADDRINUSE:                    /* Address already in use. */
            return CLARINET_EADDRINUSE;        
        case EADDRNOTAVAIL:                 /* This normally results from an attempt to bind to an address that is not valid for the local computer. */
            return CLARINET_EADDRNOTAVAIL;        
        case ENETDOWN:                      /* Network is down */
            return CLARINET_ENETDOWN;        
        case ENETUNREACH:                   /* Network is unreachable */
             return CLARINET_ENETUNREACH;        
        case ENETRESET:                     /* The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress. */
            return CLARINET_ENETRESET;
        case ECONNABORTED:                  /* An established connection was aborted by the software in your host computer (local)*/
            return CLARINET_ECONNABORTED;        
        case ECONNRESET:                    /* Connection reset by peer. An existing connection was forcibly closed by the remote host. */
            return CLARINET_ECONNRESET;        
        case ENOBUFS:                       /* No buffer space available or queue is full */
            return CLARINET_ENOBUFS;        
        case EISCONN:                       /* Socket is already connected */
            return CLARINET_EISCONN;        
        case ENOTCONN:                      /* Socket is not connected */
            return CLARINET_ENOTCONN;        
        case ESHUTDOWN:                     /* Cannot send after socket is shutdown */               
            return CLARINET_ECONNSHUTDOWN;        
        case ETIMEDOUT:                     /* Connection timed out */
            return CLARINET_ECONNTIMEOUT;        
        case ECONNREFUSED:                  /* Connection refused */
            return CLARINET_ECONNREFUSED;            
        case EHOSTDOWN:                     /* A socket operation failed because the destination host is down. Currently no documented winsock function returns this error. */
            return CLARINET_EHOSTDOWN;        
        case EHOSTUNREACH:                  /* No route to host. */
            return CLARINET_EHOSTUNREACH;        
        default:
            return CLARINET_EDEFAULT;
    }
}

int 
clarinet_socket_option_to_sockopt(int* restrict optlevel,
                                  int* restrict optname,
                                  const int proto, 
                                  const int option)
{
    CLARINET_IGNORE(optlevel);
    CLARINET_IGNORE(optname);
    CLARINET_IGNORE(proto);
    CLARINET_IGNORE(option);
    
    return CLARINET_ENOSYS;
}

CLARINET_INLINE
void
clarinet_socket_free(clarinet_socket** spp,
                     void(*destructor)(clarinet_socket* sp))
{
    if (destructor)
    {
        /* defensive:  ensure the socket is not valid anymore to avoid mistakes in the destructor */
        (*spp)->handle = INVALID_SOCKET;
        destructor(*spp);
    }
    clarinet_free(*spp);
    *spp = NULL;
}


int
clarinet_socket_close(clarinet_socket** spp,
                      void(*destructor)(clarinet_socket* sp))
{
    if (!spp || !*spp)
        return CLARINET_EINVAL;

    /* close(2) MAY only fail with  EBADF, EINTR and EIO. Both ENOSPC, EDQUOT only apply to actual files.           
     * On Linux close(2) is expected to block even with non-blocking sockets there is data to flush and a non-zero 
     * linger timeout is enabled. 
     *
     * Note that close(2) on linux is final and retrying after a failure return is the wrong thing to do, since this may 
     * cause a  reused file descriptor from another thread to be closed. This can occur because the Linux kernel always 
     * releases the file descriptor early in the close operation, freeing it for reuse; the steps that may return an 
     * error, such as flushing data to the filesystem or device, occur only later in the close operation.
     * EINTR is a somewhat special case.  Regarding the EINTR error, POSIX.1-2008 says:
     *
     *        If close() is interrupted by a signal that is to be caught, it shall return -1 with errno set to EINTR and
     *        the state of fildes is unspecified.
     *
     * This permits the behavior that occurs on Linux and many other implementations, where, as with other errors that 
     * may be reported by close(), the file descriptor is guaranteed to be closed.
     *
     * In any case we handle the possibility of EWOULDBLOCK/EAGAIN being returned as an exception to the rule. We try to 
     * change the socket to blocking and close again. We never force SO_LINGER(0) here because it is not clear what 
     * the user intentions are. There is no point in having a boolean argument for that either (e.g.: force) because the 
     * user can always adjust SO_LINGER or use the shorcut option SO_DONTLINGER at any time before closing the socket. 
     */
             
    const int sockfd = (*spp)->handle;
    if (close(sockfd) == SOCKET_ERROR)
    {
        int err = errno;
        if (err == EWOULDBLOCK || err == EAGAIN)
        {          
            setsocknonblock(sockfd);
            /* At this point if close is still failing with EWOULDBLOCK/EAGAIN we have no choice but to wait some time
             * and try again until the SO_LINGER timeout expires or the output buffer is flushed. We don't simply wait
             * for the whole SO_LINGER duration because the output buffer could be flushed way before that. This is a
             * safety mechanism because none of this should normally happen. */                       
            while (close(sockfd) == SOCKET_ERROR)
            {
                err = errno;
                if (err != EWOULDBLOCK && err != EAGAIN)
                    break;

                sleep(1);
            }
        }            
    }

    clarinet_socket_free(spp, destructor);
    return CLARINET_ENONE;
}

int
clarinet_socket_get_endpoint(clarinet_socket* restrict sp,
                             clarinet_endpoint* restrict endpoint)
{
    if (!sp | !endpoint)
        return CLARINET_EINVAL;

    struct sockaddr_storage ss = {0};
    socklen_t length = sizeof(ss);

    if (getsockname(sp->handle, (struct sockaddr*)&ss, &length) == SOCKET_ERROR)
        return clarinet_error_from_errno(errno);

    return clarinet_endpoint_from_sockaddr(endpoint, &ss);
}

int
clarinet_socket_send(clarinet_socket* restrict sp,
                     const void* restrict buf,
                     size_t buflen,
                     const clarinet_endpoint* restrict dst)
{
    if (!sp || !buf || !dst || buflen > INT_MAX)
        return CLARINET_EINVAL;
    
    if (buflen == 0)
        return CLARINET_ENONE;
       
    struct sockaddr_storage ss;
    socklen_t sslen;
    const int errcode = clarinet_endpoint_to_sockaddr(&ss, &sslen, dst);
    if (errcode != CLARINET_ENONE)
        return errcode;
    
    const ssize_t n = sendto(sp->handle, buf, buflen, 0, (struct sockaddr*)&ss, sslen);
    if (n < 0)
        return clarinet_error_from_errno(errno);
    
    return (int)n;
}

int
clarinet_socket_recv(clarinet_socket* restrict sp,
                     void* restrict buf,
                     size_t buflen,
                     clarinet_endpoint* restrict src)
{
    if (!sp || !buf || buflen == 0 || buflen > INT_MAX || !src)
        return CLARINET_EINVAL;
          
    struct sockaddr_storage ss;   
    socklen_t slen = sizeof(ss);
    const ssize_t n = recvfrom(sp->handle, buf, buflen, 0, (struct sockaddr*)&ss, &slen);
    if (n < 0)
        return clarinet_error_from_errno(errno);
    
    /* Sanity: improbable but possible */
    if (slen > sizeof(ss))
        return CLARINET_EADDRNOTAVAIL;
    
    const int errcode = clarinet_endpoint_from_sockaddr(src, &ss);
    if (errcode != CLARINET_ENONE)
        return CLARINET_EADDRNOTAVAIL;

    return (int)n;
}
